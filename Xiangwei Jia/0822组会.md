上周进度
==========
* 跑完100w条微博语料库的snownlp，情感分析效果好于原来  
* snownlp的源码理解和注释
* 之前的paper还没整理完
* 整理了吴恩达机器学习的所有笔记

snownlp源码分析（情感分析部分）
==========
snownlp github:https://github.com/isnowfy/snownlp  

调用snownlp的sentiments方法，代码如下：

```python
from snownlp import SnowNLP
 
#创建snownlp对象，设置要测试的语句
s = SnowNLP('这东西不错。。')
# 调用sentiments方法获取积极情感概率
print(s.sentiments)
```
输出：0.8371034573341097  
snownlp的情感分析中，输出在0~1之间，认为大于0.5是积极，小于0.5是消极。
## snownlp包功能
* classification
   * bayes.py
* normal
   * \__init\__.py
   * pinyin.py
   * pinyin.txt
   * stopwords.txt
   * zh.py
* seg
* sentiment
   * \__init\__.py
   * neg.txt
   * pos.txt
   * sentiment.marshal
   * sentiment.marshal.3
* sim
* summary
* tag
* untils
* \__init\__.py

## 源码分析
1、在snownlp中，查看sentiments方法，发现，sentiments中，调用了classify;</br>
代码如下：
```python
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

from . import normal
from . import seg
from . import tag
from . import sentiment
from .sim import bm25
from .summary import textrank
from .summary import words_merge


class SnowNLP(object):

    def __init__(self, doc):
        self.doc = doc
        self.bm25 = bm25.BM25(doc)

    @property
    def words(self):
        return seg.seg(self.doc)

    @property
    def sentences(self):
        return normal.get_sentences(self.doc)

    @property
    def han(self):
        return normal.zh2hans(self.doc)

    @property
    def pinyin(self):
        return normal.get_pinyin(self.doc)

    @property
    def sentiments(self):
        return sentiment.classify(self.doc)  #看到，sentiment调用classify方法；
        '''
        '''
  ```
  2、sentiment文件夹
  sentiment中，先创建了Sentiment对象  
  调用load方法，加载已经训练好的数据字典，再调用classify方法，在classify中，实际调用Bayes对象中的classify方法；  
  
  代码如下：
  ```python
  # -*- coding: utf-8 -*-
from __future__ import unicode_literals

import os
import codecs

from .. import normal
from .. import seg
from ..classification.bayes import Bayes

data_path = os.path.join(os.path.dirname(os.path.abspath(__file__)),
                         'sentiment.marshal')


class Sentiment(object):

    def __init__(self):
        #创建Bayes对象
        self.classifier = Bayes()

    #保存训练好的字典数据    
    def save(self, fname, iszip=True):
        self.classifier.save(fname, iszip)

    #加载字典数据
    def load(self, fname=data_path, iszip=True):
        self.classifier.load(fname, iszip)

    #对文档进行分词
    def handle(self, doc):
        words = seg.seg(doc)
        words = normal.filter_stop(words)
        return words

    #训练数据集
    def train(self, neg_docs, pos_docs):
        data = []
        #读取消极评论list，同时为每条评论加上neg标签，也放入一个list中
        for sent in neg_docs:
            data.append([self.handle(sent), 'neg'])
        #读取积极评论list，同时为每条评论加上pos标签，也放入一个list中
        for sent in pos_docs:
            data.append([self.handle(sent), 'pos'])
        #调用分类器的训练数据集的方法，对模型进行训练
        self.classifier.train(data)
        #此处的train方法，调用了classifier的train
        
    #分类
    def classify(self, sent):
        #调用贝叶斯分类器的分类方法，获取分类标签和概率
        ret, prob = self.classifier.classify(self.handle(sent))
        #如果分类的标签是pos，直接返回概率值
        if ret == 'pos':
            return prob
        #否则为neg标签，返回1-prob
        return 1-prob


classifier = Sentiment()
classifier.load()


#训练数据
def train(neg_file, pos_file):
    #打开消极数据文件和积极数据文件，读入neg_docs和pos_docs
    neg_docs = codecs.open(neg_file, 'r', 'utf-8').readlines()
    pos_docs = codecs.open(pos_file, 'r', 'utf-8').readlines()
    #训练数据，传入积极、消极评论的list
    classifier.train(neg_docs, pos_docs)


#保存数据字典
def save(fname, iszip=True):
    classifier.save(fname, iszip)


#加载数据字典
def load(fname, iszip=True):
    classifier.load(fname, iszip)


#对语句进行分类
def classify(sent):
    return classifier.classify(sent)
  ```

在sentiment中，包含了训练数据集的方法，sentiment文件夹中的neg.txt和pos.txt是已经分类好的评论数据，neg.txt是消极评论，pos.txt是积极评论；  
sentiment.marshal和sentiment.marshal.3中存放的是序列化后的数据字典； 
在train()方法中，首先读取消极和积极评论txt文件，然后获取每一条评论，放入到list集合中；
