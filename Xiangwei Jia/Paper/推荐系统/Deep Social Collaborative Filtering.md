# 深度社交协同过滤

## 动机

- 其他方式缺点：
  - 不充分：只捕捉直接neighbor没有远程的neighbor
  - 不特定：没有考虑具体的推荐情形，只是平等看待所有的neighbor的影响
  - 不明确：没有明确将neighbor的意见捕获到社交推荐的item-->不同观点以不同方式影响用户判断
- 本文优点：DSCF：深度社交协同过滤，可以利用推荐系统的各个方面的社交关系
- CCS概念：•信息系统→社会推荐   ;社会推荐;   •计算方法→神经网络;



>1. 信息通过社交网络传播，弱关系，远程neighbor也有影响；
>2. 需要对来自neighbor的信息针对特定item进行筛选，不能同等使用；
>3. u-i交互的评分意见会影响neighbor的评分；



## 难点：

- 远程neighbor互相之间的活动复杂，很难正确提取有用信息；
- neighbor信息的筛选相关信息很难，因为一个neighbor有很多活动；
- 捕捉u-i交互的评分也有时候比较困难(除了显性的)；

## 贡献：

- 建立DL方法从远程neighbor提取有用信息；
- 提出建模捕捉用户意见的新方法(u-i);
- 提出社交协同过滤方法，可以充分利用社交网络信息得到推荐结果；
- 对两个真实数据集实验，验证方法有效；

## DSCF框架：

### 为了利用社交网络提出建议，我们需要：

- （a）不仅考虑直接邻居而且远距离邻居的信息; 
- （b）选择每个邻居的相关信息以推荐特定项目; 
- （c）在建模用户 - 项目交互时捕获邻居对项目的意见。

### 框架：
#### 它由四层组成：
  1. 用于解决（a）和（b）挑战的随机游走层，
  2. 旨在解决挑战（c）的嵌入层
  3. 序列学习层
  4. 输出层

![title](https://i.loli.net/2019/10/10/myjXOUszT64CkRV.jpg)

## 细节：
### 1.符号约定
在介绍每一层的细节之前，我们首先介绍在本文中使用的定义和符号。
> + 令U = {u1，u2，...，uN}和V = {v1，v2，...，vM}分别表示用户和项目集，其中N是用户数，M是数量 的项目。
> + 令R∈R N×M 为评分矩阵（或用户-项目交互矩阵），其中第i，第j个元素ri，j是用户ui给出的项目vj的评分。如果用户ui尚未对item vj评分，则ri，j设置为0，这意味着该评分是未知的。
> + 用户之间的**社交网络可以用矩阵描述T∈RN×N**，如果用户ui和用户uj之间存在社会关系，则Ti，j = 1，否则为0。
> + 给定评级矩阵R和社交网络T，我们旨在预测R中的未知评级。在传统的协同过滤方法中，我们将用户和项目嵌入到低维潜在向量中。用户ui和item vj的嵌入分别表示为p [i]∈R d和q [j]∈R d，其中d是嵌入的长度。

### 2.随机游走层
> 在社交推荐中，当我们尝试为给定用户u执行推荐时，不仅他/她的直接邻居可以提供有用的信息，还可以提供几跳之内的他/她远方的邻居（或附近的neighbor）可以提供帮助。
此外，**与用户u距离不同的邻居对于推荐可能具有不同的重要性**。
因此，当包含u的邻居进行推荐时，还必须根据u与用户u的距离来区分u的邻居。
随机游走是探索网络本地邻居的一种流行工具[20，30]。
另外，**随机游走以节点序列（用户序列）[12、24]的形式探索邻居，自然而然地根据与用户u的距离保持邻居的顺序。**
因此，我们可以有效**利用随机游走从社交网络生成遥远的用户序列**。
**更具体地，可以通过从用户u开始并在L个步骤之后结束的随机游动来生成用户序列，其中l是随机游动的长度。**
所生成的用户序列可以表示为:
$$
S_{(i)}^{u}=\left\{u_{[1]}, \dots, u_{[l]}\right\}
$$

下标（i）表示$S_{(i)}^{u}$是为用户u生成的第i个用户序列，因为我们需要生成**多个用户序列以充分探究u的邻域**，并且**[k]表示 用户u [k]是用户序列中的第k个用户**。
虽然用户序列包含邻居的信息，但是没有为给定推荐情况指定它们，即，预测用户u在项目v上的偏好，因为此类信息由涉及用户u的所有推荐情况共享。但是，并非所有来自邻居的信息都有助于推荐特定项目v。只有与该项目v相关的信息才有用。
**因此，我们需要在生成的用户序列中为每个用户选择与item v相关的项目，并形成一个可感知项目的社交序列，表示为:**
$$
S_{(i)}^{u, v}=\left\{\left(u_{[1]}, v_{[1]}\right), \ldots,\left(u_{[l]}, v_{[l]}\right)\right\}
$$

请注意，**对于特定的推荐案例，仅利用最相关的项目**。
#### 原因：
+ 最相关的项目对于影响目标项目（item v）的决策最为重要，而其他项目则可能无济于事，因为它们可能会带来噪音。
+ 其次，随机游走过程会生成多个用户序列，以针对特定的推荐情况充分探索不同的相关项目，进而有助于形成这些项目感知的社交序列。

更具体地说，对于一个用户序列中的每个用户u [k]，我们从与用户u [k]进行过交互的一组商品中选择商品v [k]，如下所示：

$$
v_{[k]}=\operatorname{argmax}_{v_{h} \in \mathcal{V}_{u_{[k]}}} \operatorname{sim}\left(v_{h}, v\right)
$$

其中Vu [k]表示与用户u [k]交互的项目集，而sim（vh，v）是测量项目vh与项目v之间相似度的函数。在本文中，我们根据经验选择余弦相似度为：

$$
\begin{aligned} \operatorname{sim}\left(v_{h}, v\right) &=\frac{\mathbf{x}_{h}^{T} \mathbf{x}_{v}}{\left|\mathbf{x}_{h} \| \mathbf{x}_{v}\right|} \\ \mathbf{x}_{m} &=f\left(v_{m}\right) \end{aligned}
$$


> 其中f函数将为项目vm生成适当的特征xm。
诸如文字描述，图像的视觉内容和用户-项目交互之类的不同特征源可用于表示项目。
在本文中，由于文本描述和视觉内容等辅助信息不可用，因此我们采用用户-项目交互来表示项目。
更具体地说，我们**使用NeuMF [14]学习的项目嵌入作为项目特征来衡量项目之间的相似性**。
为预测（u，v）的评分而生成的所有项目感知社交序列的集合为
$$
S^{u, v}=\left\{S_{(i)}^{u, v}\right\}_{i=1}^{H}
$$

其中**H是社交序列的数量** 针对此推荐案例生成的。
用于预测用户u和项目v之间的交互的项目感知社交序列的优点是双重的:
+ 首先，社会序列不仅包含直接邻居，还包含遥远的邻居。
+ 其次，这些序列是特定于推荐的。

图2显示了生成项目感知社交序列的过程的示例。![title](https://i.loli.net/2019/10/10/PVT5JvyljBg9DIb.jpg)

> 我们正在预测用户u1对项目v3的评分（蜘蛛侠）。
如图所示，从源用户u1开始，我们**对直接邻居执行随机游走**。
> + 采用随机游走来生成可能的用户序列，表示为$S_{(1)}^{\text {ul }}=\left\{u_{[2]}, u_{[3]}, u_{[6]}, u_{[7]}\right\}$ 
> + 对于用户序列中的每个用户，我们需要**收集与v3最相似的项目**。
生成的项目感知社交序列为$S_{(1)}^{u_{1}, v_{3}}=\left\{\left(u_{[2]}, v_{[3]}\right),\left(u_{[3]}, v_{[5]}\right),\left(u_{[6]}, v_{[5]}\right),\left(u_{[7]}, v_{[3]}\right)\right\}$
> + 为了防止混乱，在这里，我们假设在我们的示例中，项目v5（美国队长）与项目v3（蜘蛛侠）最相似，随机游走的长度为4。

- 随机游走：--> 生成远程neighbor序列；--->方法：从u开始随机游走L步，得到neighbor序列；---> 多次随机游走得到多个序列，充分探索u的邻域；
- 需要为生成的用户序列中的用户选择一个item与item_v相关；--->形成item-aware社交序列-->只有最相关的item才会被用于特定的推荐案例。

### 3.u-i交互嵌入层
> 项目感知序列由来自用户邻居的ui交互组成，因此，我们需要首先对ui交互建模。
在对用户项目交互进行建模时，**重要的是要仔细考虑用户对交互表达的意见**。
显然，**来自用户社交邻居的好和坏意见会以极大不同的方式影响用户对商品的看法**。
**因此，我们建议在对序列中的用户-项目交互进行建模时，包括用户对项目的意见。
意见通常以评分的形式表达**。
例如，如图2所示，用户u3和用户u6都与同一项目v5（美国队长）交互； 但是，用户u6喜欢v5，而用户u3不喜欢v5。
为了对评级进行建模，我们建议**将每个离散的评级值嵌​​入到评级嵌入向量中**。
因此，如果有不同的等级，则将有等级嵌入向量。
请注意，**评分嵌入rating embedding向量也是框架的参数**。
>>等级值o的等级嵌入表示为r {o}∈R d，嵌入长度为d。

对于项目感知社交序列S u，v（i）中的交互（u [k]，v [k]），可以在评级矩阵R中找到此交互的非零评级得分，让我们表示 作为ou [k]，v [k]。
然后，相应的等级嵌入是**r {ou [k]，v [k]}**，为方便起见，我们将其表示为**r [k]**。

#### 用户和项目之间的交互是高度非线性的，并且包括评级信息进一步增加了复杂性。
+ 因此，我们使用多层感知（MLP）将**交互信息与评级信息融合**在一起。
**MLP将用户嵌入p [k]，评级嵌入r [k]，项目嵌入q [k]的串联作为输入，并输出ui交互e[k]**
$e_{\{k |}=g_{u, r, v}\left(\left[p_{[k]}, r_{[k]}, q_{[k]}\right]\right)$

**按照此过程，我们处理每个序列S u，v（i）= {（u [1]，v [1]）..（u [l]，v [l]）}，
并得到嵌入E u，v（i）= {e [1]，..e [l]}。**
从邻居得到的嵌入，用于预测（u，v）等级的所有融合交互序列的集合可以表示为E u，v

### 4.序列学习层：学习项目感知社交序列的表示形式

> 在生成（u，v）的项目感知社交序列并将序列中具有意见信息的每个用户-项目交互转换为融合交互嵌入之后，我们进入序列学习层。
**序列学习层旨在提取每个序列的特征**，然后**组合所有序列的提取特征以获得统一的表示形式，该表示形式可用于预测输出层中（u，v）的评分**。
由于序列中的所有邻居都会影响（u，v）的预测，因此对于遥远的邻居，我们需要捕获他们与用户u之间的遥远社交信息。
此外，在社交网络中，**用户会相互影响**。
因此，我们需要捕获模型中的双向影响。最近，已经提出了一种基于双向长短期记忆网络（**Bi-LSTM**）的语言模型[1，44]来捕获NLP域中**句子中单词之间的远程双向语义依赖性**。受这些模型的启发，

我们将序列视为“句子”，并将该序列中的元素视为“单词”，并采用类似的Bi-LSTM模型从融合的交互嵌入序列中提取特征。
$\overrightarrow{\mathrm{h}_{[k]}^{(i)}}=\overrightarrow{L S T M}\left(E_{(i)}^{u, v}\right), k \in[1, l]$
$\overleftarrow \mathrm{h}_{[k]}^{(i)}=\overleftarrow L S T M\left(E_{(i)}^{u, v}\right), k \in[l, 1]$

h是隐藏层状态，然后，使用**注意机制将这些与序列中的邻居相对应的隐藏状态进行组合**，以生成features $s_{(i)}^{u, v}$ of the sequence $E_{(i)}^{u, v}$
$\mathbf{s}_{(i)}^{u, v}=\sum_{k=1}^{l} \alpha_{k} \mathbf{h}_{[k]}^{(i)}$
这里的h是正向和反向隐藏状态的级联，我们使用单层网络对注意力权重αk进行参数化，并提取这些用户（邻居）-项目交互嵌入，这对于了解项目感知社交序列的表示方式至关重要。归一化重要性权重αk通过以下的Softmax函数计算：

$$\begin{aligned} \mathbf{a}_{k} &=\tanh \left(\mathbf{W}_{a} \cdot \mathbf{h}_{[k]}+\mathbf{b}_{a}\right) \\ \alpha_{k} &=\frac{\exp \left(\mathbf{a}_{k}^{T} \mathbf{a}_{u}\right)}{\sum_{j} \exp \left(\mathbf{a}_{j}^{T} \mathbf{a}_{u}\right)} \end{aligned}$$
> 其中邻居级别上下文向量`au`可以看作是固定查询“信息丰富的邻居—项目交互嵌入是什么？”在项目感知社交序列中所有邻居-项目交互嵌入上的高级表示。
请注意，邻居级上下文向量au是框架中的参数，需要在训练过程中共同学习。
然后，我们将所有用户项目交互嵌入序列的表示形式组合在一起，以生成（u，v）的项目感知社交序列的统一表示形式，如下:

$$\mathbf{s}^{u, v}=\sum_{i=1}^{H} \beta_{i} \mathbf{s}_{(i)}^{u, v}$$

在这里我们采用注意力机制来区分项目感知社会序列的重要性权重βi，如下:
$$
\begin{aligned} \mathbf{z}_{i} &=\tanh \left(\mathbf{W}_{z} \cdot \mathbf{s}_{(i)}^{u, v}+\mathbf{b}_{z}\right) \\ \beta_{i} &=\frac{\exp \left(\mathbf{z}_{i}^{T} \mathbf{z}_{u}\right)}{\sum_{j} \exp \left(\mathbf{z}_{j}^{T} \mathbf{z}_{u}\right)} \end{aligned}
$$
> `zu`可以看作是在所有社交序列上的高级表示查询“这是信息项感知的社交序列吗？”。
我们之所以要引起两点注意，是因为并非所有在一个项目感知的社交序列中与用户信息交互的意见信息都对该项目感知的社交序列具有同等的贡献。
并非所有这些序列都同样有助于（u，v）的项目感知社交序列的统一表示。

### 4.输出层
任务为rating prediction，预测u对v的评分；
$$
\begin{array}{l}{\text { The input of the output layer includes the user }} \\ {\text { embedding } \mathrm{p}_{[u]}, \text { the item embedding } \mathrm{q}_{[v]} \text { and the unified item- }} \\ {\text { aware social representations } s^{u, v} \text { learned in the sequence learning }} \\ {\text { layer. As shown in the output layer in Figure } 1, \text { a multi-layer }}\end{array}
$$
+ 输出层的三个输入：P和Q和从序列学习层得到的统一的item-aware social representations `S`；
+ 第一层MLP：用于结合p和s，把MLP表示为$f_{u,s}$
+ 第二层MLP：预测（u,v）的评分，表示为$f_{u,v}$
+ 输出层表示为：
$$
r_{u, v}^{\prime}=f_{u, v}\left(\left[\mathbf{q}_{[v]}, f_{u, s}\left(\left[\mathbf{p}_{[u]}, \mathbf{s}^{u, v}\right]\right)\right]\right)
$$

### 5.模型训练
#### 损失函数：
$$
\text {Loss }=\frac{1}{2|O|} \sum_{\left(u_{i}, v_{j}\right) \in O}\left(r_{i, j}^{\prime}-r_{i, j}\right)^{2}
$$
> 其中O表示观察到的所有用户-项目交互，| O | 是O中的交互次数，r'i，j是预测等级，而ri，j是用户ui在项目vj上分配的地面真实等级。
为了优化目标函数，我们在实现中采用了自适应矩估计（Adam）[7]作为优化器。
我们还采用辍学策略[28]来减轻优化深度神经网络模型时的过度拟合问题。
**在我们的模型中有3种嵌入，包括项嵌入qj，用户嵌入pi和等级嵌入ro**。
由于原始特征非常大且稀疏，因此我们不使用one-hot向量来表示每个用户和商品。
通过将高维稀疏特征嵌入到低维潜在空间中，可以轻松训练模型[14，38]。
等级嵌入矩阵r取决于系统的rating scale。
例如，对于5星级评分系统，评分嵌入矩阵r包含5个不同的嵌入向量，以表示{1、2、3、4、5}中的得分。

## 模型分析
### 各组件有效性分析
•DSCF-opinion：此变量使用项目感知的社交序列来代表用户的社交信息；而忽略了关于用户与项目交互的意见。
•DSCF-item&opinion：基于DSCF-opinion，它进一步消除了社交序中的关联项目。
•DSCF-ATT：此变体用于研究注意机制对学习s u，v（i）和s u，v的影响。在此变体中删除了注意机制α和β。
•DSCF-averagiong：此变体在序列学习层中通过平均序列输入中的元素来代替Bi-LSTM。
•DSCF-shuffling：此变体在序列学习层中随机重排序列中元素的顺序。

+ DSCF-Averaging变量认为序列中的所有用户对目标用户都具有相同的影响； 
+ 而DSCF-Shuffling假定影响与目标用户的距离无关。

设计这两个变体是为了了解使Bi-LSTM适应捕获项目感知社交序列的好处。

从结果中，我们得出以下结论：
+ 带有意见的项目感知社交序列。
现在，我们着重分析对交互意见的有效性。从图3中可以看出，如果忽略社交序列中关于用户与项目交互的意见（即DSCF-Opinion），DSCF的性能将大大降低，这表明有必要考虑有关交互的意见。
换句话说，使用者朋友的不同意见会以极大不同的方式影响使用者的决定。
+ 项目感知社交序列。
为了推荐一个特定项目，并非序列中来自用户的所有信息都是有用的; 换句话说，这些用户与相关项目的交互更为有用。从图3的结果来看，DSCF-Item＆Opinion的性能比DSCF和DSCF-Opinion差,这些观察结果支持了生成项目感知序列的重要性。
+ 注意机制。
从图3的结果可以看出，DSCF-ATT的性能比DSCF差。
原因是，**并非一个社交序列中的所有用户（邻居）-项目交互都为学习项目感知社交序列的表示做出了同等的贡献**。
并非所有这些项目感知社交序列都对所有项目感知社交序列的统一表示具有相同的重要性。
这些结果证明了注意力机制对学习s u，v（i）和s u，v的好处。
+ Bi-LSTM。
图4展示了Bi-LSTM对Ciao数据集的影响。
DSCF平均和DSCF改组的性能都会大大降低。
**这表明Bi-LSTM组件更好地学习了项目感知社交序列的表示形式**。
原因是社交序列反映了信息向目标用户的传播，并且对目标用户的影响应该是异类的并且与距离有关。

### 参数分析
> 所提出的框架有两个重要参数，即，每个项目感知社交序列的长度l和项目感知社交序列的数量H。
在本小节中，我们将通过检查更改一个参数并修复其他参数时性能如何变化来研究这些参数的影响。

+ 项目感知社交序列的长度l:
如果序列的长度为1，则我们的模型归结为使用直接邻居。
当序列的长度增加时，性能往往会先增加。
这表明直接邻居不能充分捕获有用的社会信息，包括远方邻居也可以提供帮助。
但是，当序列的长度太大时，性能会降低，因为我们**可能会向远处的邻居引入太多的噪声**。
+ 序列数的影响H.
通常，更多的序列可以充分探索用户的邻居，这可以帮助我们更好地理解社交信息； 然而，由于我们也可能引入噪声，因此产生太多也是有风险的。

## 结论
5结论和未来工作我们提出了一种深度社交协作过滤（DSCF），
+ 可以利用社交信息的各个方面提出建议。
+ 特别是，我们建议利用随机游走来生成项目感知的社交序列，该序列不仅考虑直接邻居的信息，还考虑远距离邻居的信息。
+ 此外，我们还引入了一种新颖的方法，可以在对用户项目互动进行建模时捕获邻居的意见。
+ 最后，提出了具有注意力机制的Bi-LSTM，以提取社交序列的特征。

我们的实验表明，**项目感知序列和意见信息在社会信息建模中起着至关重要的作用**。在两个真实世界的数据集上进行的综合实验证明了我们模型的有效性。

在这项工作中，我们仅利用用户-项目交互来度量项目之间的相似性，而丰富的辅助信息可能与项目相关联，例如文本说明和图像的视觉内容。因此，合并辅助信息将被视为一个有趣的未来方向。






 






