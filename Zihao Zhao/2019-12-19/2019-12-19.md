这周继续学习CUDA编程。还研究了目前应用最广泛的一版的CUDA版的NMS代码。比想象中复杂很多，果然再简单的一个串行算法，放在并行环境下都有可能非常复杂。之后再看看RoI_Pooling的代码。逐渐感觉CUDA编程其灵魂在于并行算法，语言只是工具，要更深入理解还是得学一些并行算法。现在在学几个最基础的并行算法比如前缀求和、归并排序、归约算法等等。这学期还剩的一个月时间里，准备继续看看并行算法，然后把CUDA学习结束掉。对了，还写了三篇博客，总结学CUDA的一些知识点。没什么人看，我觉得是好事，至少说明这个方向泡沫没那么大。

看了看之前tj3相关的一些代码，之前tj3的编译器好像比较简陋，我的理解是写了个脚本，然后按照需要的格式生成一些文件，不算一个完整的编译器。下学期开始编译器学习，发现斯坦福有一个网课不错，CS143，是讲编译器的，课程会持续11周，每周都有小作业，最后大作业会写一个编译器。准备跟着这门课入门一下编译器。

还有，算法的话MIT有一门算法导论课据说很不错，串行并行算法都会有讲到，编号是MIT6.046J，不过感觉自己是没有时间学了。感觉学这些算法比深度学习算法更实在一点，学完之后感觉确实收获到了东西。所以有时间的话还是要看看经典算法的，提高提高自己的核心能力。

